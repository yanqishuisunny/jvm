package com.shengsiyuan.jvm.bytecode;

/**
 *    字节码采用16进制计数
 * 1、使用javap -verbose命令分析一个字节码文件时，将会分析该字节码文件的魔数、版本号、常量池、类信息、
 *    类的构造方法、类中的方法信息、类变量与成员变量等信息
 * 2、魔数:所有的.class字节码文件的前4个字节都是魔数，魔数值为固定值:0xCAFEBABE
 * 3、魔数之后的4个字节为版本信息，前俩个字节表示minor version(次版本号)，后面俩个字节表示
 *    minor version(主版本号)。这个版本号00 00 00 34，换算成十进制，表示版本号为0，主版本号为52.所以该
 *    文件版本号为:1.8.0。可以通过java -version命令来验证这一点
 * 4、常量池(constant pool)：紧接着主版本号之后的就是常量池入口。一个Java类中定义的很多信息都是由常量池来
 *    维护和描述的，可以将常量池看作是Class文件的资源仓库，比如说Java类中定义的方法与变量信息，都是存储在常量池
 *    中。常量池中主要存储俩类常量:字面量与符号引用。字面量如文本字符串，Java中声明的final的常量值等。而符号
 *    引用如类和接口的全局限定名，字段的名称和描述符，方法的名称和描述等
 * 5、常量池总体结构:Java类所对应的常量池主要由常量池数量和常量池数组俩个部分共同构成。常量池数量紧跟在主版本后面，
 *    占用俩个字节。常量池数组则紧跟在常量池数量之后。常量池数组与一般的数组不同的是，常量池数组中不同的元素的类型、
 *    结构都是不同的，长度当然也就不同；但是，每一种元素的第一个数据都是一个u1类型，该字节是个标志位，占据一个字节。
 *    JVM在解析常量池时，会根据这个u1类型获取元素的具体类型。常量池数组中元素的个数 = 常量池数-1(其中0暂时不适用)，
 *    目的时满足某些常量池索引值的数据在特定情况下需要表达[不引用任何一个常量池]的含义：根本原因在于，索引为0也是
 *    一个常量(保留常量)，只不过它不位于常量表中，这个常量就对应null值；所以，常量池的索引从1而非0开始。
 * 6、在JVM规范中，每个变量/字段都有描述信息，描述信息主要的作用是描述字段的数据类型、方法的参数列表(包括数量、类型
 *    与顺序)与返回值。根据描述符规则，基本数据类型和代表无返回值的void类型都用一个大写字符来表示，对象类型则使用字
 *    符L加对象的全限定名名称来表示。为了压缩字节码文件的体积，对于基本数据类型，JVM都只使用一个大写字母来表示，如
 *    下所示:B-byte, C-char, D-double, F-float, I-int, J-long, S-short, Z-boolean, V-void, L-对象类型，
 *    如Ljava/lang/String;
 * 7、对于数组类型来说，每一个维度使用一个前置的[来表示，如int[]被记录为[I,String[][]被记录为[[Ljava/lang/String;
 * 8、用描述符描述方法时，按照先参数列表，后返回值的顺序来描述。参数列表按照参数的严格顺序放在一组（）之内，如方法：
 *    String getRealnamabyIdAndNickname(int id,String name)的描述符为:(I,Ljava/lang/String;) Ljava/lang/String;
 *
 */


/**
 * 1、winhex中0A代表的是10, 0C-12, 0B-11,
 * 2、 #1 = Methodref  #4.#21    // java/lang/Object."<init>":()V
 *    注：字节码中<init>表示该方法的构造方法 ()V表示构造方法的方法描述符。因为我们没有给这个类声明构造方法，所有
 *        这个类的构造方法是由编译器自己生成的。而这个类的父类是java.long.Object
 */

/**
 * 注：0x0021表示是0x0020和0x0001并集，表示ACC_PUBLIC与ACC_SUPER
 */

/**
 * 三个方法:还有个什么都不带的public默认构造方法
 */

public class MyTest1 {

    private  int a = 1;

    public int getA() {
        return a;
    }

    public void setA(int a) {
        this.a = a;
    }

}
